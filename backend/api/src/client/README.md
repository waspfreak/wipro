# API Client

This package contains an automatic implementation of an API client for the OneTask project.

## Getting started

Run `yarn install` to install all required dependencies

## How it works

As the AWS tooling is autogenerating for us the [graphql queries, mutations and subscriptions](src/graphql/), this client will:

* Import each of those files into a JS object.
* Iterate over each defined query/mutation/subscription and map them into a fully functioning API call.

The code for this can be seen in the [GraphQL adapter](src/GraphqlAdapter.js).

Thanks to this process, an update to the GraphQL schema will just require updating the GraphQL queries as defined [here](src/graphql/), and we'll automatically get the API client autogenerated.

## Switching environments

To switch environment you'll have to follow the instructions in the root [README file](../../README.md).

## How to use

I'd recommend to add the local package as a dependency on the frontend of choice (ensure the path to this package is correct from your project):

`npm install ../shared/apiclient`

### Creating a client

The client can be created like so:

```javascript
import APIClient from 'apiclient'

const client = new APIClient()
```

### Making a query

To query for a specific item in the database, you'll need to first find the name of the method. This can be done by looking into the graphql queries file and using the exact same name.

The parameter to filter by can be added into the method calling like so:

```javascript
await client.getUser({ id: "My ID" });
```

If you are interested in listing all objects in a table you can use the list function like so:

```javascript
await client.listUsers();
```

Under the hood, the parameter passed in will be sent later to the API by inserting them into the variables property of the [GraphQL apollo client call](https://www.apollographql.com/docs/react/data/queries/).

### Mutating data

Similarly to queries, the client will have a method in each for each of the mutations defined in the GraphQL definitions.

An example of insert, update and delete calls would be:

```javascript
const topic = await client.createTopic({
  title: "End to end test",
  description: "Topic created during an end to end test.",
  topicOwnerId: "My owner id",
  type: "TEAM",
  createdAt: new Date(),
  updatedAt: new Date(),
  startedAt: new Date(),
  endedAt: new Date()
});

await client.updateTopic({
  id: topic.id ,
  title: "Updated topic title",
  ...
});

await client.deleteTopic({
  id: createdTopic.id
});
```

### Observing data changes

We offer two different approaches to listen to data changes in the API.

#### Merged streams

The first approach is to receive in a single stream all updates possible (create/update/delete), including a property `streamType` which is either `create`, `update` or `delete` to identify the type of event that occurred.

This function is created by using subscribeTo with the table name in plural as the sufix.

Example:

```javascript
client.subscribeToTopics().subscribe({
  onNext(x) => console.log("New event of type", x.streamType),
  onError(err) => console.log("Error!", err);
  onCompleted() => console.log("Completed!");
});
```

#### Separate streams

The second approach is to receive each type of updates in a separate stream. In this approach we continue to respect the naming used in the [subscriptions.js](src/graphql/subscriptions.js) file in the [GraphQL definitions folder](src/graphql).

Example:

```javascript
client.onCreateTopic().subscribe({
  onNext(x) => console.log("Topic created", x.id),
  onError(err) => console.log("Error!", err);
  onCompleted() => console.log("Completed!");
});
client.onUpdateTopic().subscribe({
  onNext(x) => console.log("Topic updated", x.id),
  onError(err) => console.log("Error!", err);
  onCompleted() => console.log("Completed!");
});
client.onDeleteTopic().subscribe({
  onNext(x) => console.log("Topic deleted", x.id),
  onError(err) => console.log("Error!", err);
  onCompleted() => console.log("Completed!");
});
```

## Testing the client

You can use `yarn test` to execute all tests in the package. Amongst others, we have:

* An integration test in which we list and fetch data from the API if it exists.
* An end to end test in which we:
  * List users
  * Create a topic
  * Add a user as a topic member
  * Update a topic
  * Delete the topic and topic membership created
  * Subscribe to topic notifications throughout.

## Caveats

* Neither of the subscription approaches will retry if the connection fails or an unknown error occurs.
* Both of the subscription approaches will use zen-observables as an interface. This is a subset of operations as compared to RxJS but it is lightweight and already a dependency of AWS and Apollo.
* The API client is somewhat still coupled to the inner workings of ApolloClient, but if we were to switch out (unlikely), we could always respect the API as it is now and switch to another option by having a more extended API client.
* The API does not currently offer methods to encapsulate the inner workings of itself such as creating a topic with members and internally abstract the fact its multiple API calls. However, this would be easier to do and we should look for opportunities to further abstract the clients from the inner workings of the API.
